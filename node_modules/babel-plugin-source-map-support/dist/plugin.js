'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = babelPluginSourceMapSupport;

var _lodash = require('lodash.ismatch');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MODULE = 'source-map-support/register';

/*
 * XXX Babel doesn't currently provide a way to add import statements with no
 * specifiers [1], so we have to work around that by first creating an import
 * statement with a dummy specifier and then removing the specifier. this
 * works as long as we can always distinguish our import statements from import
 * statements supplied by the user.
 *
 * we could do this by passing a dummy identifier to `addImport` and then
 * looking for the exact node it returns in the AST e.g.:
 *
 *     let localIdentifier
 *
 *     Program (path, { file }) {
 *         localIdentifier = file.addImport(
 *             'source-map-support/register',
 *             'dummy'
 *         )
 *     }
 *
 *     ImportDeclaration (path) {
 *         if (path.node.local === localIdentifier) { ... }
 *     }
 *
 * but it's potentially fragile (e.g. if nodes are cloned or replaced), so
 * instead we pass an empty string as the identifier name; this
 * creates an import statement with an empty `imported` identifier e.g.:
 *
 *     import { <empty string> as whatever } from 'source-map-support/register';
 *
 * i.e.:
 *
 *     import { as whatever } from 'source-map-support/register';
 *
 * these nodes can be created by `addImport` but are otherwise invalid (Babel
 * can't print them and Babylon can't parse them) so they can't conflict with
 * anything created by the user
 *
 * [1] https://github.com/babel/babel/issues/6021
 */

/**
 * prepend:
 *
 *     import 'source-map-support/register';
 *
 * to files this plugin is used on.
 */

var DUMMY_SPECIFIER = {
    type: 'ImportSpecifier',
    imported: {
        type: 'Identifier',
        name: ''
    }
};

function babelPluginSourceMapSupport() {
    return {
        visitor: {
            Program(path, _ref) {
                var file = _ref.file;

                file.addImport(MODULE, '');
            },

            ImportDeclaration(path) {
                var _path$node = path.node,
                    source = _path$node.source,
                    specifiers = _path$node.specifiers;


                if (source.value === MODULE && specifiers.length === 1 && (0, _lodash2.default)(specifiers[0], DUMMY_SPECIFIER)) {
                    specifiers.length = 0;
                }
            }
        }
    };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBsdWdpbi5qcyJdLCJuYW1lcyI6WyJiYWJlbFBsdWdpblNvdXJjZU1hcFN1cHBvcnQiLCJNT0RVTEUiLCJEVU1NWV9TUEVDSUZJRVIiLCJ0eXBlIiwiaW1wb3J0ZWQiLCJuYW1lIiwidmlzaXRvciIsIlByb2dyYW0iLCJwYXRoIiwiZmlsZSIsImFkZEltcG9ydCIsIkltcG9ydERlY2xhcmF0aW9uIiwibm9kZSIsInNvdXJjZSIsInNwZWNpZmllcnMiLCJ2YWx1ZSIsImxlbmd0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBNER3QkEsMkI7O0FBcER4Qjs7Ozs7O0FBRUEsSUFBTUMsU0FBUyw2QkFBZjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVpBOzs7Ozs7OztBQW9EQSxJQUFNQyxrQkFBa0I7QUFDcEJDLFVBQU0saUJBRGM7QUFFcEJDLGNBQVU7QUFDTkQsY0FBTSxZQURBO0FBRU5FLGNBQU07QUFGQTtBQUZVLENBQXhCOztBQVFlLFNBQVNMLDJCQUFULEdBQXdDO0FBQ25ELFdBQU87QUFDSE0saUJBQVM7QUFDTEMsb0JBQVNDLElBQVQsUUFBeUI7QUFBQSxvQkFBUkMsSUFBUSxRQUFSQSxJQUFROztBQUNyQkEscUJBQUtDLFNBQUwsQ0FBZVQsTUFBZixFQUF1QixFQUF2QjtBQUNILGFBSEk7O0FBS0xVLDhCQUFtQkgsSUFBbkIsRUFBeUI7QUFBQSxpQ0FDVUEsS0FBS0ksSUFEZjtBQUFBLG9CQUNiQyxNQURhLGNBQ2JBLE1BRGE7QUFBQSxvQkFDTEMsVUFESyxjQUNMQSxVQURLOzs7QUFHckIsb0JBQ1FELE9BQU9FLEtBQVAsS0FBaUJkLE1BQWxCLElBQ0NhLFdBQVdFLE1BQVgsS0FBc0IsQ0FEdkIsSUFFQyxzQkFBUUYsV0FBVyxDQUFYLENBQVIsRUFBdUJaLGVBQXZCLENBSFIsRUFJRTtBQUNFWSwrQkFBV0UsTUFBWCxHQUFvQixDQUFwQjtBQUNIO0FBQ0o7QUFmSTtBQUROLEtBQVA7QUFtQkgiLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBwcmVwZW5kOlxuICpcbiAqICAgICBpbXBvcnQgJ3NvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3Rlcic7XG4gKlxuICogdG8gZmlsZXMgdGhpcyBwbHVnaW4gaXMgdXNlZCBvbi5cbiAqL1xuXG5pbXBvcnQgaXNNYXRjaCBmcm9tICdsb2Rhc2guaXNtYXRjaCdcblxuY29uc3QgTU9EVUxFID0gJ3NvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlcidcblxuLypcbiAqIFhYWCBCYWJlbCBkb2Vzbid0IGN1cnJlbnRseSBwcm92aWRlIGEgd2F5IHRvIGFkZCBpbXBvcnQgc3RhdGVtZW50cyB3aXRoIG5vXG4gKiBzcGVjaWZpZXJzIFsxXSwgc28gd2UgaGF2ZSB0byB3b3JrIGFyb3VuZCB0aGF0IGJ5IGZpcnN0IGNyZWF0aW5nIGFuIGltcG9ydFxuICogc3RhdGVtZW50IHdpdGggYSBkdW1teSBzcGVjaWZpZXIgYW5kIHRoZW4gcmVtb3ZpbmcgdGhlIHNwZWNpZmllci4gdGhpc1xuICogd29ya3MgYXMgbG9uZyBhcyB3ZSBjYW4gYWx3YXlzIGRpc3Rpbmd1aXNoIG91ciBpbXBvcnQgc3RhdGVtZW50cyBmcm9tIGltcG9ydFxuICogc3RhdGVtZW50cyBzdXBwbGllZCBieSB0aGUgdXNlci5cbiAqXG4gKiB3ZSBjb3VsZCBkbyB0aGlzIGJ5IHBhc3NpbmcgYSBkdW1teSBpZGVudGlmaWVyIHRvIGBhZGRJbXBvcnRgIGFuZCB0aGVuXG4gKiBsb29raW5nIGZvciB0aGUgZXhhY3Qgbm9kZSBpdCByZXR1cm5zIGluIHRoZSBBU1QgZS5nLjpcbiAqXG4gKiAgICAgbGV0IGxvY2FsSWRlbnRpZmllclxuICpcbiAqICAgICBQcm9ncmFtIChwYXRoLCB7IGZpbGUgfSkge1xuICogICAgICAgICBsb2NhbElkZW50aWZpZXIgPSBmaWxlLmFkZEltcG9ydChcbiAqICAgICAgICAgICAgICdzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXInLFxuICogICAgICAgICAgICAgJ2R1bW15J1xuICogICAgICAgICApXG4gKiAgICAgfVxuICpcbiAqICAgICBJbXBvcnREZWNsYXJhdGlvbiAocGF0aCkge1xuICogICAgICAgICBpZiAocGF0aC5ub2RlLmxvY2FsID09PSBsb2NhbElkZW50aWZpZXIpIHsgLi4uIH1cbiAqICAgICB9XG4gKlxuICogYnV0IGl0J3MgcG90ZW50aWFsbHkgZnJhZ2lsZSAoZS5nLiBpZiBub2RlcyBhcmUgY2xvbmVkIG9yIHJlcGxhY2VkKSwgc29cbiAqIGluc3RlYWQgd2UgcGFzcyBhbiBlbXB0eSBzdHJpbmcgYXMgdGhlIGlkZW50aWZpZXIgbmFtZTsgdGhpc1xuICogY3JlYXRlcyBhbiBpbXBvcnQgc3RhdGVtZW50IHdpdGggYW4gZW1wdHkgYGltcG9ydGVkYCBpZGVudGlmaWVyIGUuZy46XG4gKlxuICogICAgIGltcG9ydCB7IDxlbXB0eSBzdHJpbmc+IGFzIHdoYXRldmVyIH0gZnJvbSAnc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyJztcbiAqXG4gKiBpLmUuOlxuICpcbiAqICAgICBpbXBvcnQgeyBhcyB3aGF0ZXZlciB9IGZyb20gJ3NvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3Rlcic7XG4gKlxuICogdGhlc2Ugbm9kZXMgY2FuIGJlIGNyZWF0ZWQgYnkgYGFkZEltcG9ydGAgYnV0IGFyZSBvdGhlcndpc2UgaW52YWxpZCAoQmFiZWxcbiAqIGNhbid0IHByaW50IHRoZW0gYW5kIEJhYnlsb24gY2FuJ3QgcGFyc2UgdGhlbSkgc28gdGhleSBjYW4ndCBjb25mbGljdCB3aXRoXG4gKiBhbnl0aGluZyBjcmVhdGVkIGJ5IHRoZSB1c2VyXG4gKlxuICogWzFdIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9pc3N1ZXMvNjAyMVxuICovXG5cbmNvbnN0IERVTU1ZX1NQRUNJRklFUiA9IHtcbiAgICB0eXBlOiAnSW1wb3J0U3BlY2lmaWVyJyxcbiAgICBpbXBvcnRlZDoge1xuICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgIG5hbWU6ICcnXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiYWJlbFBsdWdpblNvdXJjZU1hcFN1cHBvcnQgKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHZpc2l0b3I6IHtcbiAgICAgICAgICAgIFByb2dyYW0gKHBhdGgsIHsgZmlsZSB9KSB7XG4gICAgICAgICAgICAgICAgZmlsZS5hZGRJbXBvcnQoTU9EVUxFLCAnJylcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEltcG9ydERlY2xhcmF0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UsIHNwZWNpZmllcnMgfSA9IHBhdGgubm9kZVxuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAoc291cmNlLnZhbHVlID09PSBNT0RVTEUpXG4gICAgICAgICAgICAgICAgICAgICYmIChzcGVjaWZpZXJzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgJiYgKGlzTWF0Y2goc3BlY2lmaWVyc1swXSwgRFVNTVlfU1BFQ0lGSUVSKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl19