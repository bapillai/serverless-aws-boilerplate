/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not
 * use this file except in compliance with the License. A copy of the License
 * is located at
 *
 *    http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
'use strict';

const StreamBuffer = require('./ByteStreamBuffer');
const AttributeValueEncoder = require('./AttributeValueEncoder');
const CborSExprGenerator = require('./CborSExprGenerator');
const Constants = require('./Constants');
const DocumentPath = require('./DocumentPath');
const DaxClientError = require('./DaxClientError');
const DaxErrorCode = require('./DaxErrorCode');

module.exports = class Encoders {
  constructor(encoder, keySchema, attrNames, attrListId) {
    this._encoder = encoder;
    this._keySchema = keySchema;
    this._attrNames = attrNames;
    this._attrListId = attrListId;
  }

  encodeTableName(tableName) {
    return this._encoder.encodeBinary(Buffer.from(tableName, 'utf8'));
  }

  encodeKey(keyItem) {
    return Encoders.encodeKey(keyItem, this._keySchema, this._encoder);
  }

  encodeCompoundKey(key) {
    // Compund keys ignore the key schema and simply encode what is given
    // Used for indexed Scan/Query

    let buffer = new StreamBuffer();

    buffer.write(this._encoder.encodeMapStreamHeader());

    for(let attrName in key) {
      if(Object.prototype.hasOwnProperty.call(key, attrName)) {
        buffer.write(this._encoder.encodeString(attrName));
        buffer.write(AttributeValueEncoder.encodeAttributeValue(key[attrName]));
      }
    }

    buffer.write(this._encoder.encodeStreamBreak());

    return this._encoder.encodeBinary(buffer.read());
  }

  encodeValues(item) {
    if(this._attrNames && this._attrNames.length > 0) {
      return Encoders.encodeValuesWithNames(item, this._attrNames, this._attrListId, this._encoder);
    } else {
      return Encoders.encodeValuesWithKeys(item, this._keySchema, this._attrListId, this._encoder);
    }
  }

  encodeExpressions(request) {
    let buffer = new StreamBuffer();

    let eAttrNames = request.ExpressionAttributeNames;
    let eAttrVals = request.ExpressionAttributeValues;

    AttributeValueEncoder.checkValidExprParamNames(eAttrNames ? eAttrNames : {}, eAttrVals ? eAttrVals : {});

    let expressions = CborSExprGenerator.encodeExpressions(
      request.ConditionExpression,
      request.KeyConditionExpression,
      request.FilterExpression,
      request.UpdateExpression,
      request.ProjectionExpression,
      eAttrNames, eAttrVals);

    if(request.ConditionExpression) {
      buffer.write(this._encoder.encodeInt(Constants.DaxDataRequestParam.ConditionExpression));
      buffer.write(this._encoder.encodeBinary(expressions.Condition));
    }

    if(request.FilterExpression) {
      buffer.write(this._encoder.encodeInt(Constants.DaxDataRequestParam.FilterExpression));
      buffer.write(this._encoder.encodeBinary(expressions.Filter));
    }

    if(request.UpdateExpression) {
      buffer.write(this._encoder.encodeInt(Constants.DaxDataRequestParam.UpdateExpression));
      buffer.write(this._encoder.encodeBinary(expressions.Update));
    }

    if(request.ProjectionExpression) {
      let projectionOrdinals = [];
      Encoders._prepareProjection(request.ProjectionExpression, eAttrNames, projectionOrdinals);
      request._projectionOrdinals = projectionOrdinals;

      buffer.write(this._encoder.encodeInt(Constants.DaxDataRequestParam.ProjectionExpression));
      buffer.write(this._encoder.encodeBinary(expressions.Projection));
    }

    if(eAttrNames) {
      buffer.write(this._encoder.encodeInt(Constants.DaxDataRequestParam.ExpressionAttributeNames));
      buffer.write(this._encoder.encodeMapHeader(Object.keys(eAttrNames).length));
      for(let key in eAttrNames) {
        if(Object.prototype.hasOwnProperty.call(eAttrNames, key)) {
          buffer.write(this._encoder.encodeString(key));
          buffer.write(this._encoder.encodeString(eAttrNames[key]));
        }
      }
    }

    if(eAttrVals) {
      buffer.write(this._encoder.encodeInt(Constants.DaxDataRequestParam.ExpressionAttributeValues));
      buffer.write(this._encoder.encodeMapHeader(Object.keys(eAttrVals).length));
      for(let key in eAttrVals) {
        if(Object.prototype.hasOwnProperty.call(eAttrVals, key)) {
          buffer.write(this._encoder.encodeString(key));
          buffer.write(this._encoder.encodeBinary(AttributeValueEncoder.encodeAttributeValue(eAttrVals[key])));
        }
      }
    }

    let keyCondBytes = request.KeyConditionExpression ?
      this._encoder.encodeBinary(expressions.KeyCondition) :
      null;

    return {
      otherBytes: buffer.read(),
      keyCondBytes: keyCondBytes,
    };
  }

  static encodeKey(keyItem, keySchema, encoder) {
    if(!keyItem) {
      throw new DaxClientError('Value null at \'keyItem\' failed to satisfy constraint: Member must not be null', DaxErrorCode.Validation, false);
    }

    // Extract only the key portion from the given object
    let key = {};
    for(let keyFragment of keySchema) {
      if(keyFragment.AttributeName in keyItem) {
        key[keyFragment.AttributeName] = keyItem[keyFragment.AttributeName];
      }
    }

    let itemSize = Object.keys(key).length;
    if(itemSize != keySchema.length) {
      throw new DaxClientError(
        'The number of conditions on the keys is invalid (got ' + itemSize + ', expected ' + keySchema.length + ')',
        DaxErrorCode.Validation, false);
    }

    return encoder.encodeBinary(AttributeValueEncoder.encodeKey(key, keySchema));
  }

  static encodeValuesWithNames(item, attrNames, attrListId, encoder) {
    return encoder.encodeBinary(AttributeValueEncoder.encodeAttributes(item, attrNames, attrListId));
  }

  static encodeValuesWithKeys(item, keySchema, attrListId, encoder) {
    let attrNames = AttributeValueEncoder.getCanonicalAttributeList(item, keySchema);
    return encoder.encodeBinary(AttributeValueEncoder.encodeAttributes(item, attrNames, attrListId));
  }

  static _encodeProjection(projExp, eAttrStrs) {
    if(!projExp) { // null, undefined, length 0
      return null;
    }
    // If names are null pass in empty map
    eAttrStrs = (eAttrStrs ? eAttrStrs : {});
    AttributeValueEncoder.checkValidExprParamNames(eAttrStrs, null);

    // If values are null pass in empty map
    return CborSExprGenerator.encodeProjectionExpression(projExp, eAttrStrs);
  }

  static _prepareProjection(expression, attributeNames, ords) {
    if(!expression) {
      return;
    }
    let projectionTerms = expression.split(',');
    for(let i = 0; i < projectionTerms.length; ++i) {
      ords[i] = DocumentPath.from(projectionTerms[i].trim(), attributeNames);
    }
  }

  encode_ExclusiveStartKey(request) {
    if(request.IndexName) {
      return this.encodeCompoundKey(request.ExclusiveStartKey);
    } else {
      return this.encodeKey(request.ExclusiveStartKey);
    }
  }
};

